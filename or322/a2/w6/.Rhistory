lambda = 4.8 # c/h
mu = 60/15 # (4) c/h
s = 3 # given
rho = lambda/(mu*s)
# Pi0. I made this a function of s out of habit
Pi0 = function(s) {
D = 0
for (j in 0:(s-1)) {
D = D + ( (s*rho)^j ) / (factorial(j))
}
D = D + ( (s*rho)^s ) / ( factorial(s)*(1-rho) )
return (1/D)
}
# P(j >= s)
Pj = Pi0(s)*( ((s*rho)^s) / ( factorial(s)*(1-rho) ) )
# Finally W
W = ( Pj/(s*mu-lambda) ) + 1/mu
cat(sprintf("20.10 Q1 option 1: %f", W))
W*60
# starts as self service (20.7) then another normal 20.6 queue, we will jusst sum the W
#--
# QUEUE 2.1 - SELF SERVICE (20.7)
#--
# 20.7 and 20.8 use similar equations
# 20.7 is uneque in that var approxes to lambda/mu
lambda = 4.8 # c/h
mu = 1/65 * 60 # c/h
#rho = lambda/mu # i dont know if this is the correct formula
#var = lambda/mu # E ~ V ~ lambda/mu, also sigma^2 = var
#Lq = ( lambda^2*var + rho^2 ) / ( 2*(1-rho) )
#Wq = Lq/lambda
#W1 = Wq + 1/mu
#W1 # FIXME: this seems wrong very
W1=1/mu # NOTE this comes from text book. couldn't be found any where in formula sheet or in notes
W1
#--
# QUEUE 2.2 (20.6)
#--
lambda = 4.8 # the same as in series
mu = 1/4*60 # c/h
s = 3 # given
rho = lambda/(mu*s)
W2 = ( Pj/(s*mu-lambda) ) + 1/mu # using same equations from queue option 1
W2
# PRINTS
cat(sprintf("option 2 = %f + %f = %f vs %f", W1, W2, W1+W2, W))
cat(sprintf("option 2 = %f + %f = %f vs %f", W1*60, W2*60, (W1+W2)*60, W*60))
rho
rho
s
mu = 1/4*60 # c/h
s = 3 # given
rho = lambda/(mu*s)
W2 = ( Pj/(s*mu-lambda) ) + 1/mu # using same equations from queue option 1
W2
mu
mu
lambda
rho
rho
s
rho = lambda/(mu*s)
W2 = ( Pj/(s*mu-lambda) ) + 1/mu # using same equations from queue option 1
W2
Pi0(s)
Pj
#-----------------------------------------------------------------------------------
# WINSTON 20.10 PROBLEM 1
#-----------------------------------------------------------------------------------
#-----
# Option 1
#-----
# queue(FIXME: I couldn't really figure this out myself): M/M/s/GD/inf/inf (apparently) which is a 20.6 queue, but I thought we were doing 20.10?
lambda = 4.8 # c/h
mu = 60/15 # (4) c/h
s = 3 # given
rho = lambda/(mu*s)
# Pi0. I made this a function of s out of habit
Pi0 = function(s) {
D = 0
for (j in 0:(s-1)) {
D = D + ( (s*rho)^j ) / (factorial(j))
}
D = D + ( (s*rho)^s ) / ( factorial(s)*(1-rho) )
return (1/D)
}
# P(j >= s)
Pj = function(s) {
return (
Pi0(s)*( ((s*rho)^s) / ( factorial(s)*(1-rho) ) )
)
}
# Finally W
W = ( Pj(s)/(s*mu-lambda) ) + 1/mu
cat(sprintf("20.10 Q1 option 1: %f", W))
W*60
# starts as self service (20.7) then another normal 20.6 queue, we will jusst sum the W
#--
# QUEUE 2.1 - SELF SERVICE (20.7)
#--
# 20.7 and 20.8 use similar equations
# 20.7 is uneque in that var approxes to lambda/mu
lambda = 4.8 # c/h
mu = 1/65 * 60 # c/h
#rho = lambda/mu # i dont know if this is the correct formula
#var = lambda/mu # E ~ V ~ lambda/mu, also sigma^2 = var
#Lq = ( lambda^2*var + rho^2 ) / ( 2*(1-rho) )
#Wq = Lq/lambda
#W1 = Wq + 1/mu
#W1 # FIXME: this seems wrong very
W1=1/mu # NOTE this comes from text book. couldn't be found any where in formula sheet or in notes
W1
#--
# QUEUE 2.2 (20.6)
#--
lambda = 4.8 # the same as in series
mu = 1/4*60 # c/h
s = 3 # given
rho = lambda/(mu*s)
Pi0(s)
Pj(s)
W2 = ( Pj/(s*mu-lambda) ) + 1/mu # using same equations from queue option 1
W2
W2 = ( Pj(s)/(s*mu-lambda) ) + 1/mu # using same equations from queue option 1
W2
# PRINTS
cat(sprintf("option 2 = %f + %f = %f vs %f", W1, W2, W1+W2, W))
cat(sprintf("option 2 = %f + %f = %f vs %f", W1*60, W2*60, (W1+W2)*60, W*60))
# PRINTS
cat(sprintf("option 2 = %f + %f = %f vs %f", W1, W2, W1+W2, W))
cat(sprintf("option 1 is faster than option 2))
cat(sprintf("option 1 is faster than option 2"))
# PRINTS
cat(sprintf("option 2 = %f + %f = %f vs %f", W1, W2, W1+W2, W))
cat(sprintf("option 1 is faster than option 2"))
# PRINTS
cat(sprintf("option 2 = %f + %f = %f(Op2) vs %f(Op1)", W1, W2, W1+W2, W))
cat(sprintf("option 1 is faster than option 2"))
rbar=c(1/6,0,0)  #parts/minute
mubar=c(1/3,1/2,1) #parts/minute
P=matrix(c(0,0,0.1,1,0,0.2,0,1,0),ncol = 3)
P
lambdabar=solve(diag(3)-t(P))%*%rbar  #parts/minute
lambdabar
L=function(lambda,mu)return(lambda/(mu-lambda))
L_bar=c()
for(i in 1:3)L_bar[i]=L(lambdabar[i],mubar[i])
L_bar
L_tau=sum(L_bar) #parts
cat("The number of parts in the system is on average ",L_tau,"parts.")
P=matrix(c(0,0,0.1,1,0,0.2,0,1,0),ncol = 3)
P
P=matrix(c(0,0,0.1,1,0,0.2,0,1,0),row = 3, byrow=TRUE)
P=matrix(c(0,0,0.1,1,0,0.2,0,1,0),row = 3, byrow = TRUE)
P=matrix(c(0,0,0.1,1,0,0.2,0,1,0), nrow = 3, byrow = TRUE)
P
P=matrix(c(
0, 1, 0
0, 0, 1
0.1, 0.2, 0
), nrow = 3, byrow = TRUE)
P
P=matrix(c(
0, 1, 0
0, 0, 1
0.1, 0.2, 0
), nrow = 3, byrow = TRUE)
P=matrix(c(
0, 1, 0,
0, 0, 1,
0.1, 0.2, 0
), nrow = 3, byrow = TRUE)
P
rbar=c(
120,0,0)  # c/h
mubar=c(
1/20*60*60, # c/h
1/2,
1) #parts/minute
mubar
P=matrix(c(
0, 1, 0,
0, 0, 1,
0, 0, 0
), nrow = 3, byrow = TRUE)
P
lambdabar=solve(diag(3)-t(P))%*%rbar  #parts/minute
lambdabar
L=function(lambda,mu)return(lambda/(mu-lambda))
L_bar
for(i in 1:3)L_bar[i]=L(lambdabar[i],mubar[i])
L_bar
L_tau=sum(L_bar) #parts
L_tau
lambdabar
# a. 11/3 students
11/3
lambdabar=solve(diag(3)-t(P))%*%rbar  #parts/minute
lambdabar
L=function(lambda,mu)return(lambda/(mu-lambda))
L_bar=c()
for(i in 1:3)L_bar[i]=L(lambdabar[i],mubar[i])
L_bar
L_tau=sum(L_bar) #parts
cat("The number of parts in the system is on average ",L_tau,"parts.")
Pij = matrix(c(
1, 0, 0,
0, 1, 0,
0, 0, 1
), nrow=3, byrow=TRUE)
Pij
rownames(Pij) = c("a", "b", "c")
Pij
Pij = matrix(c(
0, 0, 0,
0, 0, 0,
0, 0, 0
), nrow=3, byrow=TRUE)
rownames(Pij) = c("1", "2", "3")
colnames(Pij) = c("1", "2", "3")
Pij
# DR J example
rbar = c(
3, # c/h
2, # c/h
5 # c/h
)
Pij = matrix(c(
0, 0.4, 0.4,
0.2, 0, 0.5,
0.2, 0.4, 0.2
), nrow=3, byrow=TRUE) # FIXME: Why p don't sum to 1?
rownames(Pij) = c("1", "2", "3")
colnames(Pij) = c("1", "2", "3")
Pij
mubar = c(
10, # c/h
15, # c/h
20  # c/h
)
lambdabar  = solve(diag(3)-t(Pij))%*%rbar
lambdabar
L = function(lambda, mu) {
return(lambda/(mu-lambda))
}
Lbar=c() # this will contain all the Li values
for (i in 1:3) {
Lbar[i] = L(lambdabar[i]/(lambdabar[i]-mubar[i]))
}
Lbar=c() # this will contain all the Li values
for (i in 1:3) {
Lbar[i] = L(lambdabar[i], mubar[i])
}
Lbar
Ltau = sum(Lbar)
Wtau = Ltau/sum(rbar)
Ltau
Wtau
# DR J example
rbar = c(
3, # c/h
2, # c/h
5 # c/h
)
mubar = c(
10, # c/h
15, # c/h
20  # c/h
)
Pij = matrix(c(
0, 0.4, 0.4,
0.2, 0, 0.5,
0.2, 0.4, 0.2
), nrow=3, byrow=TRUE) # FIXME: Why p don't sum to 1?
rownames(Pij) = c("1", "2", "3")
colnames(Pij) = c("1", "2", "3")
Pij
P=matrix(c(0,0,0.1,1,0,0.2,0,1,0),ncol = 3)
P
P=matrix(c(
1, 0, 0,
0, 1, 0,
0, 0, 1
), nrow=3, byrow=TRUE)
P
P=matrix(c(
0, 0, 0,
0, 0, 0,
0.1, 0.2, 0
), nrow=3, byrow=TRUE)
P
P=matrix(c(0,0,0.1,1,0,0.2,0,1,0),ncol = 3)
P
# FIXME: I don't follow how this is accurate
P=matrix(c(0,0,0.1,1,0,0.2,0,1,0),ncol = 3)
P
P=matrix(c(0,0,0.1,1,0,0.2,0,1,0),ncol = 3)
P
P=matrix(c(
0, 1, 0,
0, 0, 1,
0.1, 0.2, 0
), nrow=3, byrow=TRUE)
P
lambdabar=solve(diag(3)-t(P))%*%rbar  #parts/minute
P=matrix(c(
0, 1, 0,
0, 0, 1,
0.1, 0.2, 0
), nrow=3, byrow=TRUE)
P
P=matrix(c(0,0,0.1,1,0,0.2,0,1,0),ncol = 3)
P
lambdabar=solve(diag(3)-t(P))%*%rbar  #parts/minute
lambdabar
L=function(lambda,mu)return(lambda/(mu-lambda))
L_bar=c()
L_bar
for(i in 1:3) {
L_bar[i]=L(lambdabar[i],mubar[i])
}
L_bar
L_tau=sum(L_bar) #parts
cat("The number of parts in the system is on average ",L_tau,"parts.")
rbar=c(
120,0,0)  # c/h
mubar=c(
1/20*60*60, # c/h
1/15*60*60, # c/h
1/12*60*60) # c/h
P=matrix(c(
0, 1, 0,
0, 0, 1,
0, 0, 0
), nrow = 3, byrow = TRUE)
P
lambdabar=solve(diag(3)-t(P))%*%rbar  #parts/minute
lambdabar
L=function(lambda,mu)return(lambda/(mu-lambda))
L_bar=c()
for(i in 1:3)L_bar[i]=L(lambdabar[i],mubar[i])
L_bar
L_tau=sum(L_bar) #parts
cat("The number of parts in the system is on average ",L_tau,"parts.")
P = matrix(c(
0, 0, 0,
0, 0, 0,
0, 0, 0
), nrows=3, byrow=TRUE)
P
P = matrix(c(
0, 0, 0,
0, 0, 0,
0, 0, 0
), nrows=3, byrow=TRUE)
P = matrix(c(
0, 0, 0,
0, 0, 0,
0, 0, 0
), nrow=3, byrow=TRUE)
P
lambdabar = solver(diag(3)-t(P))%*%rbar
lambdabar = solve(diag(3)-t(P))%*%rbar
lambdabar
rbar = c(
10, # jobs/hour
0, # jobs/hour
0 # jobs/hour
)
mubar = c(
20, # jobs/hour
20, # jobs/hour
20 # jobs/hour
)
P = matrix(c(
0, 0, 1,
0.1, 0, 0.9,
0, 0.2, 0
), nrow=3, byrow=TRUE)
P
lambdabar = solve(diag(3)-t(P))%*%rbar
lambdabar
L = function(lambda, mu) {
return(lambda/(mu-lambda))
}
Lbar = c()
for (i in 1:3) {
Lbar[i] = L(lambdabar[i], mu[i])
}
Lbar
Ltau = sum(Lbar)
Ltau
lambdabar
Lbar = c()
for (i in 1:3) {
Lbar[i] = lambdabar[i]/(mubar[i]-lambdabar[i])#L(lambdabar[i], mu[i])
}
Lbar
Ltau = sum(Lbar)
Ltau
#-----
# a)
#-----
L = function(lambda, mu) {
return(lambda/(mu-lambda))
}
Lbar = c()
for (i in 1:3) {
Lbar[i] = L(lambdabar[i], mubar[i])
}
Lbar
Ltau = sum(Lbar)
Ltau
cat(sprintf("20.10 Q6a: %f", Ltau))
Wtau = Ltau/sum(rbar)
Wtau
Wtau*60
0.416*60
0.413*60
P=matrix(c(
0, 1, 0,
0, 0, 1,
0, 0, 0
), nrow = 3, byrow = TRUE)
P
lambdabar=solve(diag(3)-t(P))%*%rbar  #parts/minute
lambdabar
#-----
# PRE CALCULATIONS
#-----
rbar = c(
10, # jobs/hour
0, # jobs/hour
0 # jobs/hour
)
mubar = c(
20, # jobs/hour
20, # jobs/hour
20 # jobs/hour
)
P = matrix(c(
0, 0, 1,
0.1, 0, 0.9,
0, 0.2, 0
), nrow=3, byrow=TRUE)
P
lambdabar = solve(diag(3)-t(P))%*%rbar
lambdabar
#-----
# PRE CALCULATIONS
#-----
rbar = c(
10, # jobs/hour
0, # jobs/hour
0 # jobs/hour
)
mubar = c(
20, # jobs/hour
20, # jobs/hour
20 # jobs/hour
)
P = matrix(c(
0, 0, 1,
0.1, 0, 0.9,
0, 0.2, 0.8
), nrow=3, byrow=TRUE)
P
lambdabar = solve(diag(3)-t(P))%*%rbar
lambdabar
lambdabar = solve(diag(3)-t(P))%*%rbar
#-----
# PRE CALCULATIONS
#-----
rbar = c(
10, # jobs/hour
0, # jobs/hour
0 # jobs/hour
)
mubar = c(
20, # jobs/hour
20, # jobs/hour
20 # jobs/hour
)
P = matrix(c(
0, 0, 1,
0.1, 0, 0.9,
0, 0.2, 0
), nrow=3, byrow=TRUE)
P
lambdabar = solve(diag(3)-t(P))%*%rbar
lambdabar
#-----
# c)
#-----
Wtau = Ltau/sum(rbar)
cat(sprintf("20.10 Q6a: %f", Wtau))
cat(sprintf("20.10 Q6a: %f jobs/hour", Wtau))
cat(sprintf("20.10 Q6a: %f jobs/minute", Wtau*60))
cat(sprintf("20.10 Q6a: %f hours or %f minutes", Wtau, Wtau*60))
#-----
# b)
#-----
L = function(lambda, mu) {
return(lambda/(mu-lambda))
}
Lbar = c()
for (i in 1:3) {
Lbar[i] = L(lambdabar[i], mubar[i])
}
Lbar
Ltau = sum(Lbar)
Ltau
